using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace SquidCraft.Network.Generator;

/// <summary>
/// Source generator that automatically discovers all classes marked with [NetworkMessage]
/// and generates a NetworkMessagesUtils class with a pre-populated Messages list.
/// </summary>
[Generator]
public class NetworkMessagesSourceGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        // Register a syntax receiver that will be created for each generation pass
        context.RegisterForSyntaxNotifications(() => new NetworkMessageSyntaxReceiver());
    }

    public void Execute(GeneratorExecutionContext context)
    {
        // Retrieve the populated receiver
        if (context.SyntaxContextReceiver is not NetworkMessageSyntaxReceiver receiver)
            return;

        // Get all candidate classes
        var messageClasses = new List<(string FullTypeName, string MessageType)>();

        foreach (var classDeclaration in receiver.CandidateClasses)
        {
            var model = context.Compilation.GetSemanticModel(classDeclaration.SyntaxTree);
            var classSymbol = model.GetDeclaredSymbol(classDeclaration);

            if (classSymbol == null)
                continue;

            // Look for NetworkMessageAttribute
            var attribute = classSymbol.GetAttributes()
                .FirstOrDefault(ad => ad.AttributeClass?.Name == "NetworkMessageAttribute");

            if (attribute == null)
                continue;

            // Extract the NetworkMessageType enum value
            if (attribute.ConstructorArguments.Length > 0)
            {
                var messageTypeArg = attribute.ConstructorArguments[0];
                if (messageTypeArg.Value != null && messageTypeArg.Type is INamedTypeSymbol enumType)
                {
                    var fullTypeName = classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
                        .Replace("global::", "");

                    // Get the enum member name from the value (handles byte, int, etc.)
                    var enumValue = messageTypeArg.Value;
                    var enumMemberName = enumType.GetMembers()
                        .OfType<IFieldSymbol>()
                        .FirstOrDefault(f => f.HasConstantValue && f.ConstantValue?.Equals(enumValue) == true)
                        ?.Name;

                    if (enumMemberName != null)
                    {
                        messageClasses.Add((fullTypeName, enumMemberName));
                    }
                }
            }
        }

        if (messageClasses.Count == 0)
            return;

        // Sort by message type for consistency
        messageClasses.Sort((a, b) => string.Compare(a.MessageType, b.MessageType, System.StringComparison.Ordinal));

        // Generate the source code
        var source = GenerateNetworkMessagesUtilsClass(messageClasses);

        // Add the source to the compilation
        context.AddSource("NetworkMessagesUtils.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static string GenerateNetworkMessagesUtilsClass(List<(string FullTypeName, string MessageType)> messageClasses)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using SquidCraft.Network.Data.Services;");
        sb.AppendLine("using SquidCraft.Network.Types;");
        sb.AppendLine();
        sb.AppendLine("namespace SquidCraft.Network.Generated;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Auto-generated utility class containing all registered network messages.");
        sb.AppendLine("/// This class is generated by NetworkMessagesSourceGenerator.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("public static class NetworkMessagesUtils");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Gets a read-only list of all network messages discovered at compile-time.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static IReadOnlyList<NetworkMessageData> Messages { get; } = new List<NetworkMessageData>");
        sb.AppendLine("    {");

        foreach (var (fullTypeName, messageType) in messageClasses)
        {
            sb.AppendLine($"        new(typeof({fullTypeName}), NetworkMessageType.{messageType}),");
        }

        sb.AppendLine("    };");
        sb.AppendLine("}");

        return sb.ToString();
    }
}

/// <summary>
/// Syntax receiver that collects all class declarations for analysis.
/// </summary>
internal class NetworkMessageSyntaxReceiver : ISyntaxContextReceiver
{
    public List<ClassDeclarationSyntax> CandidateClasses { get; } = new List<ClassDeclarationSyntax>();

    public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
    {
        // Look for class declarations with attributes
        if (context.Node is ClassDeclarationSyntax classDeclaration &&
            classDeclaration.AttributeLists.Count > 0)
        {
            CandidateClasses.Add(classDeclaration);
        }
    }
}

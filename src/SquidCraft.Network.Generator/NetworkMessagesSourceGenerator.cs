using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace SquidCraft.Network.Generator;

/// <summary>
/// Source generator that automatically discovers all classes marked with [NetworkMessage]
/// and generates a NetworkMessagesUtils class with a pre-populated Messages list.
/// </summary>
[Generator]
public class NetworkMessagesSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Create a pipeline that finds all classes with attributes
        var classDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsCandidateClass(node),
                transform: static (ctx, _) => GetSemanticTarget(ctx))
            .Where(static m => m is not null);

        // Collect all results and generate source
        var compilation = context.CompilationProvider.Combine(classDeclarations.Collect());

        context.RegisterSourceOutput(compilation,
            static (spc, source) => Execute(spc, source.Left, source.Right!));
    }

    private static bool IsCandidateClass(SyntaxNode node)
    {
        // Look for class declarations with attributes
        return node is ClassDeclarationSyntax { AttributeLists.Count: > 0 };
    }

    private static ClassDeclarationSyntax? GetSemanticTarget(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;

        // Get the semantic model
        var classSymbol = context.SemanticModel.GetDeclaredSymbol(classDeclaration);
        if (classSymbol == null)
            return null;

        // Check if it has NetworkMessageAttribute
        var hasNetworkMessageAttribute = classSymbol.GetAttributes()
            .Any(ad => ad.AttributeClass?.Name == "NetworkMessageAttribute");

        return hasNetworkMessageAttribute ? classDeclaration : null;
    }

    private static void Execute(
        SourceProductionContext context,
        Compilation compilation,
        ImmutableArray<ClassDeclarationSyntax?> classDeclarations)
    {
        if (classDeclarations.IsDefaultOrEmpty)
            return;

        // Get all candidate classes and extract their message types
        var messageClasses = new List<(string FullTypeName, string MessageType)>();

        foreach (var classDeclaration in classDeclarations)
        {
            if (classDeclaration == null)
                continue;

            var model = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
            var classSymbol = model.GetDeclaredSymbol(classDeclaration);

            if (classSymbol == null)
                continue;

            // Look for NetworkMessageAttribute
            var attribute = classSymbol.GetAttributes()
                .FirstOrDefault(ad => ad.AttributeClass?.Name == "NetworkMessageAttribute");

            if (attribute == null)
                continue;

            // Extract the NetworkMessageType enum value
            if (attribute.ConstructorArguments.Length > 0)
            {
                var messageTypeArg = attribute.ConstructorArguments[0];
                if (messageTypeArg.Value != null && messageTypeArg.Type is INamedTypeSymbol enumType)
                {
                    var fullTypeName = classSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
                        .Replace("global::", "");

                    // Get the enum member name from the value (handles byte, int, etc.)
                    var enumValue = messageTypeArg.Value;
                    var enumMemberName = enumType.GetMembers()
                        .OfType<IFieldSymbol>()
                        .FirstOrDefault(f => f.HasConstantValue && f.ConstantValue?.Equals(enumValue) == true)
                        ?.Name;

                    if (enumMemberName != null)
                    {
                        messageClasses.Add((fullTypeName, enumMemberName));
                    }
                }
            }
        }

        if (messageClasses.Count == 0)
            return;

        // Sort by message type for consistency
        messageClasses.Sort((a, b) => string.Compare(a.MessageType, b.MessageType, System.StringComparison.Ordinal));

        // Generate the source code
        var source = GenerateNetworkMessagesUtilsClass(messageClasses);

        // Add the source to the compilation
        context.AddSource("NetworkMessagesUtils.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static string GenerateNetworkMessagesUtilsClass(List<(string FullTypeName, string MessageType)> messageClasses)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using SquidCraft.Network.Data.Services;");
        sb.AppendLine("using SquidCraft.Network.Types;");
        sb.AppendLine();
        sb.AppendLine("namespace SquidCraft.Network.Generated;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Auto-generated utility class containing all registered network messages.");
        sb.AppendLine("/// This class is generated by NetworkMessagesSourceGenerator.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("public static class NetworkMessagesUtils");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Gets a read-only list of all network messages discovered at compile-time.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static IReadOnlyList<NetworkMessageData> Messages { get; } = new List<NetworkMessageData>");
        sb.AppendLine("    {");

        foreach (var (fullTypeName, messageType) in messageClasses)
        {
            sb.AppendLine(string.Format(System.Globalization.CultureInfo.InvariantCulture,
                "        new(typeof({0}), NetworkMessageType.{1}),", fullTypeName, messageType));
        }

        sb.AppendLine("    };");
        sb.AppendLine("}");

        return sb.ToString();
    }
}
